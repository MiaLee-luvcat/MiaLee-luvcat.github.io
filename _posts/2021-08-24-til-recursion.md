---
published: true
title:  "[TIL] 재귀함수"
excerpt: "[자료구조/알고리즘] 기초 - 재귀"

categories:
  - TIL
tags:
  - [Algorithm, 자료구조, 재귀함수, Recursion, TIL]

toc: true
toc_sticky: true
 
date: 2021-08-24 19:03:00
last_modified_at: 2022-03-21 19:04:00
---

## 들어가기 전에
세션 2에 들어오고 처음으로 배우는 자료구조와 알고리즘 파트!  
여전히 내가 세션 1을 무사히 마치고 세션2에 왔다는 것에 안심 반, 걱정 반인 마음이다.  
일부러 재수강하는 분들도 있다는데 내가 와도 되는 걸까 싶은 마음...  
그래도... 저번에도 말했듯 정신 빠짝 차려서 내가 통과될 만하니까 온 거라는 자신감을 갖고 나아가자!  


# [자료구조/알고리즘] 기초 - 재귀  
## 재귀 소개  
어떤 문제가 있다고 가정해 보자. 이 문제를 동일한 구조의 더 작은 문제로 나눌 수 있고(쪼개기), 이 작은 문제를 해결함으로써 전체 문제를 해결하는 방법을 재귀(recursion)라고 한다.  
재귀를 사용한 코드는 대부분 더욱 간결하고, 이해하기 쉽다. 그 밖에도 재귀는 알고리즘 문제의 많은 부분을 차지한다.  

## Achievement Goals  
**Lesson - 재귀 함수**  
* 재귀의 의미에 대해서 이해하고, 자바스크립트에서 재귀 호출을 할 수 있다.  
* 재귀를 언제 사용해야 하는지 알고 있다.  
* 재귀적 사고 연습을 통해 재귀 함수를 base case와 recursive case로 나눠서 작성할 수 있다.  
* 자료 구조 중 Tree 구조에 재귀 함수를 사용하는 이유를 이해할 수 있다.  
  * 실생활에 사용되는 유용한 Tree 구조를 알고 있다.  
  * 깊이를 알 수 없는 Tree 구조에 재귀 함수를 활용하여 모두 순회(traverse)할 수 있다.  

<br>

## 재귀의 이해 - 다르게 생각하기  
이번 유닛엔 조금 특별한 문제 해결 방법을 배우게 된다. 이번 유닛의 학습목표는 재귀를 학습하고 연습하면서 하나의 문제를 해결하기 위해 다양한 방식으로 생각하는 능력을 기르는 것이다.  

이 새로운 문제 해결 방법을 학습하기 전에, 다음의 간단한 문제를 해결해 볼 것이다.  

> 문제.  
> 자연수로 이루어진 리스트(배열)를 입력받고, 리스트의 합을 리턴하는 함수 `arrSum` 을 작성하세요.  
> 바로 정답을 확인하지 말고, 직접 코드를 작성하세요.  


**내가 푼 코드**
```js
function arrSum(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
      sum += arr[i];
  }

  return sum;
}
```

### 정답  
* 자연수로 이루어진 리스트(배열)의 합을 구하는 알고리즘  
  a. 보조 변수 sum을 0으로 초기화한다.  
  b. 순차적으로 리스트(배열)의 구성요소에 접근하면서 sum에 더한다.  
* 코드
```js
function arrSum(arr) {
  let sum = 0;
  for (let i = 0; i < arr.length; i++) {
    sum += arr[i];
  }
  return sum;
}
```
<center>[코드] 자연수로 이루어진 리스트(배열)의 합을 구하는 arrSum</center>
<br>

이번에는 이 문제를 다른 각도에서 생각해 보겠다.  
자연수로 이루어진 리스트(배열) `[10, 3, 6, 2]`의 합을 구한다고 가정하자.  
1. 전체 리스트 `[10, 3, 6, 2]`의 합을 구하는 건 잠시 잊어버리자. 대신에 `[3, 6, 2]`의 합을 구하는 방법을 생각해 본다.  
  * `[10, 3, 6, 2]`보다는 `[3, 6, 2]`의 길이가 더 짧아서, 비교적 쉽게 풀릴 것 같다. 리스트 `[3, 6, 2]`의 합을 구하는 방법을 알아냈다면, 이 값에 `10`을 더해 주어진 문제인 리스트 `[10, 3, 6, 2]`의 합을 구할 수 있다.  
2. 리스트 `[3, 6, 2]`의 합을 구하는 게 조금 버겁다. 대신에 `[6, 2]`의 합을 구하는 방법을 생각해 보자.  
  * 1과 같은 이유로 `[3, 6, 2]`보다는 `[6, 2]`의 길이가 더 짧다. `[6, 2]`의 합을 구하는 방법을 알아냈다면, 이 값에 `3`을 더해 리스트 `[3, 6, 2]`의 합을 구할 수 있다.  
  * `arrSum([3, 6, 2]) = 3 + arrSum([6, 2])`  
3. 같은 이유로 `[6, 2]` 대신 `[2]`의 합을 구하는 방법을 생각해 보자. `[2]`의 합에 `6`을 더해 `[6, 2]`의 합을 구할 수 있다.  
4. `[2]`의 합을 구하는 건 매우 간단합니다. `2`다.  
<br>
이 과정을 아래의 간단한 코드로 표현할 수 있다.  

```js
arrSum([10, 3, 6, 2]) = 10 + arrSum([3, 6, 2]);
arrSum([3, 6, 2]) = 3 + arrSum([6, 2]);
arrSum([6, 2]) = 6 + arrSum([2]);
arrSum([2]) = 2 + arrSum([]);
arrSum([]) = 0;
```
<br>

## 문제를 쪼개어 생각하는 방법  
이처럼 어떤 문제를 해결할 때, 동일한 구조의 더 작은 문제를 해결함으로써 주어진 문제를 해결하는 방법을 **재귀(recursion)**라고 한다.  
재귀의 과정을 위에서 다뤘던 `arrSum`에 적용하면, 다음과 같다.  

1\. 기존의 문제에서 출발하여 더 작은 경우를 생각한다.  
  ```js
  arrSum([10, 3, 6, 2]) = 10 + arrSum([3, 6, 2]);
  ```  
  <center>[코드] arrSum에 적용할 문제를 더 작게 쪼갠다.</center>
<br>
2\. 같은 방식으로, 문제가 더는 작아지지 않을 때까지 더 작은 경우를 생각한다.  
  ```js
  arrSum([3, 6, 2]) = 3 + arrSum([6, 2]);  
  arrSum([6, 2]) = 6 + arrSum([2]);  
  arrSum([2]) = 2 + arrSum([]);  
  ```
  <center>[코드] arrSum에 적용할 문제를 가장 작은 단위까지 쪼갠다.</center>  
<br>
3\. 문제가 간단해져서 바로 풀 수 있게 되는 순간부터 앞서 생성한 문제를 차근차근 해결한다.  

```js
arrSum([]) = 0; // <-- 문제가 더는 작아지지 않는 순간
// 가장 작은 경우의 해결책을 적용한다.
arrSum([2]) = 2 + arrSum([]) = 2;
arrSum([6, 2]) = 6 + arrSum([2]) = 6 + 2 = 8;
arrSum([3, 6, 2]) = 3 + arrSum([6, 2]) = 3 + 8 = 11;
arrSum([10, 3, 6, 2]) = 10 + arrSum([3, 6, 2]) = 10 + 11 = 21;
```
<center>[코드] 가장 작은 단위부터 arrSum을 적용하여 문제를 푼다.</center>
<br>
다음과 같이, `arrSum`을 보다 엄밀하게(formally) 정의할 수 있다.  

```js
/*
 * 1. arr이 빈 배열인 경우 = 0
 * 2. 그 외의 경우 = arr[0] + arrSum(arr2)
 *   (arr2는 arr의 첫 요소를 제외한 나머지 배열)
 */
arrSum(arr);
```
<center>[코드] 함수 arrSum의 엄밀한 정의</center>
<br>
만약 함수 `arrSum`을 JavaScript 코드로 구현할 경우 (코플릿 과제 중 하나!), 함수 `arrSum`은 (인자가 빈 배열이 아닌 경우) 실행 과정 중에 자기 자신을 호출한다! 이러한 호출 방식을 **재귀 호출**이라고 한다.  

<br/>
<br/>