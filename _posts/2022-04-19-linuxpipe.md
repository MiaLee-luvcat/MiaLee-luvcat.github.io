---
published: true
title:  "[Linux] pipe (`|`)란? + redirection(`>`)과의 차이"
excerpt: ""

categories:
  - Programming Language
tags:
  - [Programming Language, Linux, pipe, redirection]

toc: true
toc_sticky: true
 
date: 2022-04-19 21:36:00
last_modified_at: 2022-04-19 21:36:00
---

## pipe(`|`) - 파이프?  
보통 리눅스라고 하면 '터미널'(혹은 iTerm2)을 켜서 쉘을 사용하는 걸 떠올리곤 한다.  
가장 많이 쓰는 명령어로는 `ls`, `cd`, `cat`, `nano` 등이 있는데, 이러한 명령어들을 더욱 강력하게 활용하기 위한 기능 중 하나가 파이프(`|`)이다.  

사용법과 예시를 들기 전에 한 가지 상황을 비유해보겠다.  
한 액체가 흐를 수 있는 관이 있다고 가정하자. 이 관 안에선 터미널에 명령어를 **입력**하여 **실행**하고 **결과**가 나오는 하나의 과정이 이루어진다. 마치 액체를 입구에 주입하고 관 내부에서 흘러 출구로 나오듯 말이다.  

그런데 이곳에 파이프(`|`)라는 필터관이 추가된다고 하자.  
필터관을 쓰면 새로운 명령어에 따른 입력/실행/결과의 과정이 처음 관에서의 결과에 추가로 덧씌워진다.  
이렇게 되면 두 가지의 명령어를 동시에 만족하는 결과가 나온다고 생각하면 된다.  

만약 처음 관에서 초콜릿을 내보내라는 명령어를 쓰고, 파이프관을 추가로 써서 동그라미 모양만 내보내라 했다면  
동그라미 모양의 초콜릿만 나오게 되는 것이다. 

> 첫 명령어 `|` 두 번째 명령어 `|` 세 번째 명령어  

즉 첫 명령어 결과를 파이프를 통해 두 번째 명령어 단계로, 그 결과를 또 파이프를 통한 세 번째 명령어 단계로 이어가는 것이다.  


## 사용 방법 및 예시
**1**  
`ls`를 사용하게 되면 그 위치의 파일, 폴더 등이 특정 조건에 맞게 정렬되어 출력될 것이다.
그렇다면 `sort`는? 아마 그냥 `sort`만 쓰면 아무 일도 벌어지지 않을 것이다.  
다만 파이프로를 이용해 `ls | sort -r`을 하게 되면 그냥 `ls`를 썼을 때와 달리 역순으로 정렬되어 출력될 것이다.  

```shell
# ls
a.txt
b.txt
c.txt

# ls | sort -r
c.txt
b.txt
a.txt
```

**2**  
`more` 명령어는 `sort`처럼 그냥 쓸 수 없고 파일명과 함께 쓰며 화면 단위로 끊어 출력해 주는 명령어이다.  
이를 `ls`와 함께 쓰면 어떻게 될까?  
한 폴더에서 `ls` 명령어를 썼더니 30여 개의 목록이 떠서 스크롤을 해야 했던 상황이 있다고 하면,  
`more`명령어로 인해 보이는 터미널 화면 내부까지만 출력되고 그 다음엔 엔터를 연달아 치며 그다음 목록을 출력하게 된다.  

```shell
// 8줄만 보이는 터미널 창 크기라고 가정.

# ls
1
2
3
4
5
6
... // 생략 + 아래로 스크롤
30

# ls | more
1
2
3
4
5
6
: // 여기서 enter를 누르면 그다음 목록이 이어짐

```

## redirection(`>`)과의 차이점  
재지향이라고도 불리는 redirection(`>`)은 한 명령어로 인해 출력되는 데이터를 다른 장치로 보내는 역할을 한다.  
파이프와 가장 큰 차이점은  
파이프의 경우 첫 명령어의 output(stdout)을 다음 명령어(프로그램)의 input(stdin)으로 쓴다면,  
재지향의 경우 첫 명령어의 output을 다음에 오는 파일에 저장하거나 다른 스트림으로 넘긴다는 것이다.  

파이프 : `프로그램(명령어) | 프로그램(명령어)`  
재지향 : `프로그램(명령어) > 파일`  

다른 스트림으로 넘기는 상황은 다음과 같다.  
만약 test0.txt 파일이 존재하지 않는데 그것을 test1.txt 이름으로 복사-저장한다고 해보자. 그러면 `cat test0.txt > test1.txt`의 명령어를 쓰게 되는데 `cat: test0.txt: No such file or directory`라는 오류와 눈이 마주치게 될 것이다. (단 test1.txt 파일 자체는 만들어진다.)  
그럴 때 이렇게 하는 것이다.  
`cat test0.txt > test1.txt 2> error.log`  
2는 리눅스에서 표준에러이기에 `2>`를 사용함으로써 에러처리를 하겠다는 의미가 된다.  
이렇게 되면 아까와 같이 빈 내용의 test1.txt 파일이 만들어짐과 동시에 error.log라는 파일이 만들어지며 `cat: test0.txt: No such file or directory`라는 내용이 담겨지게 된다.  



<br>

<br>
